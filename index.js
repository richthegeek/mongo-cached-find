// Generated by CoffeeScript 1.7.1
(function() {
  var CachedFind, EventEmitter, HashMap, MongoOplog, Promise, getNamespace, getServerAddress, getWatcher, sift,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  sift = require('sift');

  MongoOplog = require('mongo-oplog');

  Promise = require('bluebird');

  HashMap = require('hashmap').HashMap;

  EventEmitter = require('events').EventEmitter;

  CachedFind = (function(_super) {
    __extends(CachedFind, _super);

    function CachedFind(collection, query) {
      var ns;
      this.collection = collection;
      this.query = query != null ? query : {};
      ns = getNamespace(collection);
      this.sifter = sift(query);
      this.documents = new HashMap();
      this.refresh();
      this.watcher = getWatcher(collection);
      this.watcher.then((function(_this) {
        return function(watcher) {
          _this.emit('tailing', watcher);
          _this.refresh();
          watcher.on('insert', function(event) {
            if (event.ns === ns) {
              if (_this.check(event.o)) {
                return _this.add(event.o);
              }
            }
          });
          watcher.on('update', function(event) {
            if (event.ns === ns) {
              if (_this.check(event.o)) {
                return _this.add(event.o);
              } else {
                return _this.remove(event.o._id);
              }
            }
          });
          return watcher.on('remove', function(event) {
            if (event.ns === ns) {
              return _this.remove(event.o._id);
            }
          });
        };
      })(this));
    }

    CachedFind.prototype.refresh = function(callback) {
      return this.pendingQuery = new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.collection.find(_this.query).toArray(function(err, rows) {
            var row, _i, _len;
            if (err) {
              _this.emit('error', err);
              if (typeof callback === "function") {
                callback(err);
              }
              return reject(err);
            } else {
              _this.documents.clear();
              for (_i = 0, _len = rows.length; _i < _len; _i++) {
                row = rows[_i];
                _this.documents.set(row._id, row);
              }
              _this.emit('init', rows);
              if (typeof callback === "function") {
                callback(null, rows);
              }
              return resolve();
            }
          });
        };
      })(this));
    };

    CachedFind.prototype.check = function(document) {
      return this.sifter.test(document);
    };

    CachedFind.prototype.add = function(document) {
      this.documents.set(document._id, document);
      return this.emit('add', document);
    };

    CachedFind.prototype.remove = function(id) {
      if (this.documents[id]) {
        this.documents.remove(id);
        return this.emit('remove', id);
      }
    };

    CachedFind.prototype.get = function(cb) {
      var bad, good;
      good = (function(_this) {
        return function() {
          return cb(null, _this.documents.values());
        };
      })(this);
      bad = function(reason) {
        return cb(reason);
      };
      return this.pendingQuery.then(good, bad);
    };

    return CachedFind;

  })(EventEmitter);

  getNamespace = function(collection) {
    return collection.db.databaseName + '.' + collection.collectionName;
  };

  getServerAddress = function(collection) {
    var address, host, port;
    host = collection.db.serverConfig.host;
    port = collection.db.serverConfig.port;
    return address = "mongodb://" + host + ":" + port;
  };

  getWatcher = function(collection) {
    var address;
    address = getServerAddress(collection) + '/local';
    if (!module.exports.watchers[address]) {
      module.exports.watchers[address] = new Promise(function(resolve, reject) {
        var watcher;
        watcher = MongoOplog(address);
        return watcher.tail(function() {
          return resolve(watcher);
        });
      });
    }
    return module.exports.watchers[address];
  };

  module.exports = function(collection, query) {
    var address, key, ns;
    address = getServerAddress(collection);
    ns = getNamespace(collection);
    key = JSON.stringify({
      address: address,
      ns: ns,
      query: query
    });
    if (!module.exports.caches.has(key)) {
      console.log('NEW CF', ns, query);
      module.exports.caches.set(key, new CachedFind(collection, query));
    }
    return module.exports.caches.get(key);
  };

  module.exports.watchers = new HashMap();

  module.exports.caches = new HashMap();

}).call(this);
